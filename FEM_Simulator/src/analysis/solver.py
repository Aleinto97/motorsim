"""Mesh-import-agnostic 2-D magnetostatic solver.

Loads Gmsh ``.msh`` files via *meshio* and converts them to DOLFINx data
structures without touching ``dolfinx.io.gmshio`` (which currently crashes on
Apple-silicon/Open-MPI builds).

The module exports a single public function ``run_analysis`` that preserves the
original call signature used by the unit-tests (*mesh_path* first).  It also
provides detailed error messages when mesh conversion or the solve phase fail.
"""

from __future__ import annotations

from pathlib import Path
import traceback

import numpy as np
import meshio
import scipy.constants
import ufl
from dolfinx import fem, mesh, plot as dfx_plot
from dolfinx.fem.petsc import LinearProblem
from mpi4py import MPI
import pyvista as pv
import basix.ufl as basix_ufl
from src.core.regions import Region
from src.core.models import MotorParameters

__all__ = ["run_analysis"]


# -----------------------------------------------------------------------------
# Mesh helpers
# -----------------------------------------------------------------------------


def _create_dolfinx_mesh_from_meshio(
    msh: meshio.Mesh,
) -> tuple[mesh.Mesh, mesh.MeshTags, mesh.MeshTags, dict[int, str]]:
    """Convert *meshio* Gmsh mesh → DOLFINx mesh + cell/facet tags."""

    # --- domain cells ---
    tri_cells = np.asarray(msh.get_cells_type("triangle"), dtype=np.int64)
    if tri_cells.size == 0:
        raise ValueError("Mesh contains no triangular cells.")

    gdim = msh.points.shape[1]
    coord_el = basix_ufl.element("Lagrange", "triangle", 1, shape=(gdim,))
    ufl_domain = ufl.Mesh(coord_el)

    domain = mesh.create_mesh(
        MPI.COMM_WORLD,
        tri_cells,
        msh.points.astype(np.float64),
        ufl_domain,
        mesh.create_cell_partitioner(mesh.GhostMode.none),
    )

    # --- cell MeshTags ---
    phys_cell = np.asarray(msh.get_cell_data("gmsh:physical", "triangle"), dtype=np.int32)
    cell_tags = mesh.meshtags(domain, domain.topology.dim, np.arange(tri_cells.shape[0], dtype=np.int32), phys_cell)

    # --- facet MeshTags (lines) ---
    line_cells = np.asarray(msh.get_cells_type("line"), dtype=np.int64)
    phys_line = np.asarray(msh.get_cell_data("gmsh:physical", "line"), dtype=np.int32)

    # Build mapping edge-(sorted vertex ids) → facet index in DOLFINx
    domain.topology.create_entities(domain.topology.dim - 1)
    domain.topology.create_connectivity(domain.topology.dim - 1, 0)
    f2v = domain.topology.connectivity(domain.topology.dim - 1, 0)

    edge_to_facet: dict[tuple[int, int], int] = {}
    for facet in range(f2v.num_nodes):
        verts = np.sort(f2v.links(facet))
        edge_to_facet[tuple(verts)] = facet

    facet_indices: list[int] = []
    facet_values: list[int] = []
    for edge, tag in zip(line_cells, phys_line):
        key = tuple(np.sort(edge))
        facet_idx = edge_to_facet.get(key)
        if facet_idx is None:
            # Skip edges that do not correspond to an exterior facet (e.g. when
            # Gmsh writes duplicate lines for periodic boundaries).
            continue
        facet_indices.append(facet_idx)
        facet_values.append(tag)

    facet_tags = mesh.meshtags(
        domain,
        domain.topology.dim - 1,
        np.asarray(facet_indices, dtype=np.int32),
        np.asarray(facet_values, dtype=np.int32),
    )

    # --- mapping tag → name ---
    tag_to_name = {int(v[0]): k for k, v in msh.field_data.items()}

    return domain, cell_tags, facet_tags, tag_to_name


# -----------------------------------------------------------------------------
# Main entry-point
# -----------------------------------------------------------------------------


def run_analysis(
    mesh_path: Path,
    phase_currents: dict[str, float] | None = None,
    *,
    model: "MotorParameters | None" = None,
):
    """Run a 2-D magnetostatic analysis.

    Parameters
    ----------
    mesh_path
        Path to the ``.msh`` triangulation generated by the project's geometry
        builder.
    phase_currents
        Mapping ``{"A": IA, "B": IB, "C": IC}`` with phase currents in *A*.
        Missing phases default to *0 A*.
    model
        Optional :class:`~src.core.models.MotorParameters` instance.  Required
        only if you want a more sophisticated parameterisation of source terms
        (e.g. magnet remanence).  When *None*, sensible defaults are used.
    """

    print("\n--- Magnetostatic Analysis (meshio bridge) ---")

    phase_currents = phase_currents or {}

    try:
        # ------------------------------------------------------------------
        # 1. Import mesh through meshio and convert to DOLFINx structures
        # ------------------------------------------------------------------
        print(f"Loading mesh with meshio → {mesh_path}")
        msh = meshio.read(mesh_path)

        domain, cell_tags, facet_tags, tag_to_name = _create_dolfinx_mesh_from_meshio(msh)
        print("Mesh imported successfully –", len(tag_to_name), "physical tags")

        # ------------------------------------------------------------------
        # 2. Function spaces and material/source fields
        # ------------------------------------------------------------------
        V = fem.functionspace(domain, ("CG", 1))
        DG0 = fem.functionspace(domain, ("DG", 0))
        vec_el = basix_ufl.element("DG", "triangle", 0, shape=(2,))
        W = fem.functionspace(domain, vec_el)

        mu_r = fem.Function(DG0, name="mu_r")
        Jz = fem.Function(DG0, name="Jz")
        mu_r.x.array.fill(1.0)  # air everywhere by default
        Jz.x.array.fill(0.0)

        mu_0 = scipy.constants.mu_0

        # ------------------------------------------------------------------
        # 3. Assign materials and physically derived source terms
        # ------------------------------------------------------------------

        Br = 1.25  # Tesla (N38SH)
        J_eq_magnet = 0.15 * Br / mu_0  # empirical 2-D scaling

        # Fallback constant current density when no detailed *model* is passed
        DEFAULT_COIL_DENSITY = 5.0e6  # 5 A/mm² in A/m²

        # --- steel regions & coil windings first ---
        for tag, name in tag_to_name.items():
            cells = cell_tags.find(tag)
            if cells.size == 0:
                continue

            if "steel" in name:
                mu_r.x.array[cells] = 1.0e3

            elif name.startswith("phase_"):
                phase = name.split("_", 1)[1].upper()
                I_phase = float(phase_currents.get(phase, 0.0))

                if abs(I_phase) > 0:
                    # --------------------------------------------------
                    # Physically derived current density for the slot
                    # --------------------------------------------------
                    # Use *model* if provided; otherwise fall back to default
                    mp = model if isinstance(model, MotorParameters) else MotorParameters()

                    if mp is not None:
                        N_cond = mp.winding.num_conductors_per_slot
                        A_slot = mp.stator.slot.slot_area
                        K_fill = mp.winding.fill_factor

                        A_copper = A_slot * K_fill
                        if A_copper <= 1e-12:
                            raise ValueError("Slot area or fill factor is too small for current density computation.")

                        N_turns = N_cond / 2  # two conductors per turn (out & return)
                        NI = N_turns * I_phase

                        J_coil = 0.2 * NI / A_copper  # scaled to avoid deep saturation
                    else:
                        # Shouldn't happen, but keep legacy behaviour
                        J_coil = I_phase * DEFAULT_COIL_DENSITY

                    print(f"  - Phase {phase}: Applying Jz={J_coil:.3e} A/m^2")
                    Jz.x.array[cells] = J_coil

        # --- magnet regions with alternating polarity per *surface* ---
        magnet_groups = {tag: nm for tag, nm in tag_to_name.items() if "magnet" in nm}
        for idx, tag in enumerate(sorted(magnet_groups)):
            polarity = 1 if idx % 2 == 0 else -1
            cells = cell_tags.find(tag)
            if cells.size:
                Jz.x.array[cells] = polarity * J_eq_magnet

        # Synchronise modified function values across processes
        Jz.x.scatter_forward()
        mu_r.x.scatter_forward()

        # ------------------------------------------------------------------
        # 4. Dirichlet boundary A_z = 0 on outer boundary
        # ------------------------------------------------------------------
        outer_tag = next((t for t, n in tag_to_name.items() if n == Region.OUTER_BOUNDARY.value), None)
        if outer_tag is None:
            raise RuntimeError("'outer_boundary' physical group not found in mesh.")

        facets_outer = facet_tags.find(outer_tag)
        if facets_outer.size == 0:
            raise RuntimeError("No facets tagged as 'outer_boundary'.")

        # Ensure facet-to-cell connectivity exists (required by locate_dofs_topological)
        domain.topology.create_connectivity(domain.topology.dim - 1, domain.topology.dim)

        bc_dofs = fem.locate_dofs_topological(V, domain.topology.dim - 1, facets_outer)
        bc = fem.dirichletbc(fem.Constant(domain, 0.0), bc_dofs, V)

        # ------------------------------------------------------------------
        # 5. Variational formulation and solve
        # ------------------------------------------------------------------
        u, v = ufl.TrialFunction(V), ufl.TestFunction(V)
        a = (1.0 / (mu_0 * mu_r)) * ufl.dot(ufl.grad(u), ufl.grad(v)) * ufl.dx
        L = Jz * v * ufl.dx

        print("Solving linear system…")
        problem = LinearProblem(a, L, bcs=[bc], petsc_options={"ksp_type": "preonly", "pc_type": "lu"})
        Az = problem.solve()
        Az.name = "A_z"
        print("→ Solver finished.")

        # ------------------------------------------------------------------
        # 6. Post-processing: compute B-field and wrap in a PyVista grid
        # ------------------------------------------------------------------
        B = fem.Function(W, name="B")
        expr = fem.Expression(ufl.as_vector((Az.dx(1), -Az.dx(0))), W.element.interpolation_points())
        B.interpolate(expr)

        grid = None
        if MPI.COMM_WORLD.rank == 0:
            try:
                from dolfinx.plot import create_vtk_mesh  # type: ignore

                cells, cell_types, geometry = create_vtk_mesh(domain, domain.topology.dim)
                grid = pv.UnstructuredGrid(cells, cell_types, geometry)
                B_vec = B.x.array.reshape(-1, 2)
                grid.cell_data["B_mag"] = np.linalg.norm(B_vec, axis=1)
            except (ImportError, AttributeError):
                # Plotting helper not available in this build – skip grid creation
                grid = None

        # --- simple torque placeholder using axial length ---
        L_motor = model.L_motor if model else 0.05
        torque = 0.0  # TODO: implement Maxwell stress; placeholder

        return {"Az": Az, "B": B, "grid": grid, "torque": torque}

    except Exception:  # pragma: no cover – capture full traceback for the test log
        traceback.print_exc()
        return None 