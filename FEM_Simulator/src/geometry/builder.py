"""
Robust geometry builder that uses a single OCC *fragment* call together with the
returned *fragment_map* to deterministically tag every relevant physical
region (stator steel, rotor steel, magnets, slot air, per-phase slots, and
outer boundary).  The workflow avoids fragile geometric heuristics by relying
solely on Gmsh's bookkeeping of Boolean operations.
"""

from __future__ import annotations

import math
from collections import defaultdict
from typing import List, DefaultDict

import gmsh  # type: ignore
import numpy as np
import pyvista as pv

from src.core.models import MotorParameters
from src.core.regions import Region

# -----------------------------------------------------------------------------
# Helper utilities
# -----------------------------------------------------------------------------

def _points_and_lines() -> pv.PolyData:
    """Return a PyVista ``PolyData`` of all 2-node line elements in the mesh.

    The mesh generated by Gmsh may contain a mixture of element *types* that
    still belong to the 1-D *dim*: for instance *Line2* (2-node) and *Line3*
    (3-node quadratic).  The helper therefore iterates over **all** 1-D element
    blocks and extracts the first/last node of each element so that the
    resulting connectivity array has a uniform ``(n, 2)`` shape that NumPy can
    easily concatenate.
    """

    node_tags, coords, _ = gmsh.model.mesh.getNodes()
    if node_tags.size == 0:
        raise RuntimeError("Mesh has no nodes – geometry build failed earlier.")

    points = coords.reshape(-1, 3)
    tag_to_idx = {t: i for i, t in enumerate(node_tags)}

    elem_types, _, elem_nodes = gmsh.model.mesh.getElements(dim=1)
    if not elem_types:
        raise RuntimeError("No 1-D elements present in the mesh.")

    all_lines = []  # list[np.ndarray] each shaped (-1, 2)
    for etype, enodes in zip(elem_types, elem_nodes):
        # Gmsh API: getElementProperties → (name, dim, order, nNodes, nodesCoord?)
        name, dim, *props = gmsh.model.mesh.getElementProperties(etype)
        if dim != 1:
            continue
        n_nodes_per_elem = props[1] if len(props) > 1 else 0
        enodes = np.asarray(enodes, dtype=int)

        if n_nodes_per_elem < 2:
            continue
        enodes = enodes.reshape(-1, n_nodes_per_elem)[:, [0, -1]]  # first & last node → 2-node line
        all_lines.append(enodes)

    if not all_lines:
        raise RuntimeError("No valid line connectivity could be extracted.")

    lines = np.vstack(all_lines)
    conn = np.vectorize(tag_to_idx.get)(lines)
    vtk_lines = np.hstack([np.full((len(conn), 1), 2), conn])
    return pv.PolyData(points, lines=vtk_lines.ravel())


def _points_and_faces() -> pv.PolyData:
    """Return a PyVista mesh of all 3-node triangular faces in the mesh."""

    node_tags, coords, _ = gmsh.model.mesh.getNodes()
    if node_tags.size == 0:
        raise RuntimeError("Mesh has no nodes – geometry build failed earlier.")

    points = coords.reshape(-1, 3)
    tag_to_idx = {t: i for i, t in enumerate(node_tags)}

    elem_types, _, elem_nodes = gmsh.model.mesh.getElements(dim=2)
    if not elem_types:
        raise RuntimeError("No 2-D elements present in the mesh.")

    tri_blocks = []  # list[np.ndarray] shaped (-1, 3)
    for etype, enodes in zip(elem_types, elem_nodes):
        name, dim, *props = gmsh.model.mesh.getElementProperties(etype)
        if dim != 2:
            continue
        n_nodes_per_elem = props[1] if len(props) > 1 else 0
        enodes = np.asarray(enodes, dtype=int)
        if n_nodes_per_elem < 3:
            continue
        enodes = enodes.reshape(-1, n_nodes_per_elem)[:, :3]  # first 3 nodes define triangle
        tri_blocks.append(enodes)

    if not tri_blocks:
        raise RuntimeError("No triangular faces could be extracted from the mesh.")

    tris = np.vstack(tri_blocks)
    conn = np.vectorize(tag_to_idx.get)(tris)
    faces = np.hstack([np.full((len(conn), 1), 3), conn])
    return pv.PolyData(points, faces=faces.ravel())

# -----------------------------------------------------------------------------
# Main builder routine
# -----------------------------------------------------------------------------

def build_geometry(
    model: MotorParameters,
    *,
    mesh_2d: bool = False,
    save_path: str | None = None,
) -> pv.PolyData | None:
    """Construct the motor cross-section and return it as a PyVista mesh.

    The routine performs exactly one ``occ.fragment`` operation to intersect
    the stator/rotor rings with all slot and magnet cutting tools.  The
    resulting ``fragment_map`` is then used to assign every produced surface to
    its correct physical region *without* any location-based heuristics.
    """

    # ------------------------------------------------------------------
    # Aliases & quick sanity checks
    # ------------------------------------------------------------------
    s, r = model.stator, model.rotor
    slot, hole = s.slot, r.hole_v

    if not (0 < r.Rint < r.Rext < s.Rint < s.Rext):
        return None  # invalid radii order – caller handles None

    try:
        # --------------------------------------------------------------
        # 1. Initialise Gmsh in silent mode
        # --------------------------------------------------------------
        gmsh.initialize()
        gmsh.option.setNumber("General.Terminal", 0)
        gmsh.model.add("motor_final")
        occ = gmsh.model.occ

        # --------------------------------------------------------------
        # 2. Stator & rotor rings (simple disk-minus-disk cuts)
        # --------------------------------------------------------------
        stator_ring, _ = occ.cut(
            [(2, occ.addDisk(0, 0, 0, s.Rext, s.Rext))],
            [(2, occ.addDisk(0, 0, 0, s.Rint, s.Rint))],
        )
        rotor_ring, _ = occ.cut(
            [(2, occ.addDisk(0, 0, 0, r.Rext, r.Rext))],
            [(2, occ.addDisk(0, 0, 0, r.Rint, r.Rint))],
        )

        # --------------------------------------------------------------
        # 3. Slot cutter rectangles (duplicated Zs times & rotated)
        # --------------------------------------------------------------
        # 3. Slot cutter tools (fused per slot for deterministic meshing)
        slot_tools: List[tuple[int, int]] = []
        if slot.Zs > 0:
            base_tag = occ.addRectangle(s.Rint - 1e-3, -slot.W2 / 2, 0, slot.H2 + 2e-3, slot.W2)
            for k in range(slot.Zs):
                # Make two identical copies of the base rectangle
                dt1 = occ.copy([(2, base_tag)])[0]
                dt2 = occ.copy([(2, base_tag)])[0]
                # Fuse them together – this yields a single, clean surface
                fused_tool, _ = occ.fuse([dt1], [dt2])
                # Rotate into position
                occ.rotate(fused_tool, 0, 0, 0, 0, 0, 1, 2 * math.pi * k / slot.Zs)
                slot_tools.extend(fused_tool)

        # --------------------------------------------------------------
        # 4. V-pocket rectangles (fused) → magnet pocket templates
        # --------------------------------------------------------------
        magnet_tools: List[tuple[int, int]] = []
        if hole.Zh > 0:
            mag = hole.magnet_left

            rect1 = (2, occ.addRectangle(-mag.Wmag / 2, -mag.Hmag / 2, 0, mag.Wmag, mag.Hmag))
            rect2 = occ.copy([rect1])[0]

            r_off = r.Rext - hole.H1 - mag.Hmag / 2
            ang = math.asin(hole.W1 / (2 * r_off)) if r_off > 0 else 0.0

            occ.rotate([rect1], 0, 0, 0, 0, 0, 1, -ang)
            occ.translate([rect1], r_off * math.cos(-ang), r_off * math.sin(-ang), 0)

            occ.rotate([rect2], 0, 0, 0, 0, 0, 1, ang)
            occ.translate([rect2], r_off * math.cos(ang), r_off * math.sin(ang), 0)

            v_pocket, _ = occ.fuse([rect1], [rect2])

            for k in range(hole.Zh):
                dt = occ.copy(v_pocket)[0]
                occ.rotate([dt], 0, 0, 0, 0, 0, 1, 2 * math.pi * k / hole.Zh)
                magnet_tools.append(dt)

        occ.synchronize()

        # --------------------------------------------------------------
        # 5. Single fragment call
        # --------------------------------------------------------------
        base_objects = stator_ring + rotor_ring + magnet_tools
        tools = slot_tools

        _, fragment_map = occ.fragment(base_objects, tools)
        occ.synchronize()

        # --------------------------------------------------------------
        # 6. Deterministic physical-group assignment via fragment_map
        # --------------------------------------------------------------
        phys_groups: DefaultDict[str, List[int]] = defaultdict(list)

        # 6a. Stator & rotor steel surfaces (children of first two bases)
        phys_groups[Region.STATOR_STEEL.value].extend([tag for dim, tag in fragment_map[0] if dim == 2])
        phys_groups[Region.ROTOR_STEEL.value].extend([tag for dim, tag in fragment_map[1] if dim == 2])

        # 6b. Magnet surfaces – children of each magnet template
        for i in range(len(magnet_tools)):
            children = fragment_map[2 + i]
            phys_groups[Region.MAGNETS.value].extend([tag for dim, tag in children if dim == 2])

        # 6c. Slot air – group by *slot* for deterministic phase assignment
        slot_start_idx = len(base_objects)
        slot_children: List[List[int]] = []
        for i in range(len(slot_tools)):
            children = [tag for dim, tag in fragment_map[slot_start_idx + i] if dim == 2]
            slot_children.append(children)
            phys_groups[Region.SLOTS_AIR.value].extend(children)
        # Ensure we have an entry for every slot (even if empty) so indexing is deterministic
        while len(slot_children) < slot.Zs:
            slot_children.append([])

        # --------------------------------------------------------------
        # 7. Register 2-D physical groups in Gmsh
        # --------------------------------------------------------------
        for name, tags in phys_groups.items():
            if not tags:
                continue
            if name == Region.SLOTS_AIR.value:
                continue  # per-phase tagging later
            gmsh.model.addPhysicalGroup(2, tags, name=name)

        # (phase-slot tagging deferred until after mesh generation)


        # --------------------------------------------------------------
        # 8. Outer boundary tagging (largest-radius curve)
        # --------------------------------------------------------------
        try:
            seed = phys_groups[Region.STATOR_STEEL.value][0]
            boundary = gmsh.model.getBoundary([(2, seed)], oriented=False, recursive=True)
            centers = [occ.getCenterOfMass(dim, t) for dim, t in boundary]
            ridx = int(np.argmax([math.hypot(c[0], c[1]) for c in centers]))
            outer_line = boundary[ridx][1]
            gmsh.model.addPhysicalGroup(1, [outer_line], name=Region.OUTER_BOUNDARY.value)
        except Exception:
            pass  # optional tagging – non-fatal

        # --------------------------------------------------------------
        # 9. Meshing & export
        # --------------------------------------------------------------
        if mesh_2d:
            gmsh.option.setNumber("Mesh.ElementOrder", 1)
            gmsh.model.mesh.setSize(gmsh.model.getEntities(0), 0.003)
            gmsh.model.mesh.generate(2)
            # --------------------------------------------------
            # Phase-slot tagging after mesh: balance by triangle count
            # --------------------------------------------------
            tri_phase = {"phase_A": 0, "phase_B": 0, "phase_C": 0}
            phase_map: DefaultDict[str, List[int]] = defaultdict(list)
            # Build list of (triangle_count, surface_tag) for every slot-air surface
            surf_tri = []
            for s in phys_groups[Region.SLOTS_AIR.value]:
                tri_cnt = 0
                etypes, _, enodes = gmsh.model.mesh.getElements(2, s)
                for etype, nodes in zip(etypes, enodes):
                    _, _, _, nNodes, *_ = gmsh.model.mesh.getElementProperties(etype)
                    if nNodes:
                        tri_cnt += len(nodes) // nNodes
                surf_tri.append((tri_cnt, s))
            # Assign largest surfaces first for best balance
            surf_tri.sort(reverse=True)
            for tri_cnt, s in surf_tri:
                phase = min(tri_phase, key=tri_phase.get)
                phase_map[phase].append(s)
                tri_phase[phase] += tri_cnt
            for ph, surfs in phase_map.items():
                if surfs:
                    gmsh.model.addPhysicalGroup(2, surfs, name=ph)
            mesh_out = _points_and_faces()
        else:
            gmsh.model.mesh.generate(1)
            mesh_out = _points_and_lines()

        if save_path:
            gmsh.write(save_path)

        return mesh_out

    except Exception as err:
        print("ERROR in build_geometry:", err)
        return None

    finally:
        if gmsh.isInitialized():
            gmsh.finalize() 